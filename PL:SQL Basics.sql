
/*
PL/SQL Basics
*** ***
*/

-- Question 2 

SET SERVEROUTPUT ON;

-- Question 1
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello World');
END;
/
/* Q1 Results 
Hello World
*/

Instructor
| 09/28 at 6:24 pm
Grading comment:
Q1 should be run when you haven't set serveroutput on, so there should be no output


-- Question 3

BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello World');
END;
/
Instructor
| 09/28 at 6:24 pm
Grading comment:
Does SQL Developer “remember” your SERVEROUTPUT preference?

/* Q3 Results
Umm PL/SQL procedure successfully completed.

Hello World
*/
--Question 4 
/*
The SERVEROUTPUT attribute is a SQL*Plus setting that controls whether output generated by the DBMS_OUTPUT package in PL/SQL is displayed to the user. By default, the setting is OFF, 
meaning any calls to DBMS_OUTPUT.PUT  are stored in an internal buffer but not shown on the screen. When you issue SET SERVEROUTPUT ON, the client enables DBMS_OUTPUT.ENABLE behind the scenes, 
creating a buffer on the server to capture the messages and then automatically retrieving and displaying them after a PL/SQL block finishes executing.
Source: https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_OUTPUT.html#GUID-770FBCCF-C95F-41D6-96E4-553EE49EDB16
*/
-- Question 5

BEGIN
  DBMS_OUTPUT.PUT_LINE('The Ubiquitous Hello World');
END;
/

/* Q5 Results 
PL/SQL procedure successfully completed.

The Ubiquitous Hello World
*/

--Question 6 
BEGIN
  DBMS_OUTPUT.PUT('The');
  DBMS_OUTPUT.PUT(' ');
  DBMS_OUTPUT.PUT('Ubiquitous');
  DBMS_OUTPUT.PUT('');
  DBMS_OUTPUT.PUT('Hello');
  DBMS_OUTPUT.PUT('');
  DBMS_OUTPUT.PUT_LINE('World');
END;
/

/*Q6 Results 

PL/SQL procedure successfully completed.

The UbiquitousHelloWorld
*/

/*Question 7 
DBMS_OUTPUT.PUT writes text to the output buffer without a newline
DBMS_OUTPUT.PUT_LINE writes text and appends a newline, so the next output starts on a new line.
Source: https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_OUTPUT.html
*/

/*Question 8 
PUT is a procedure in the DBMS_OUTPUT package that places text into the DBMS_OUTPUT buffer (to be retrieved/displayed by the client); it does not add a newline at the end.
Source: https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_OUTPUT.html

*/

/*Question 9 
PUT_LINE is a procedure in the DBMS_OUTPUT package that places a line of text
into the DBMS_OUTPUT buffer and terminates it with a newline, so each call appears on a separate line when displayed
Source: https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_OUTPUT.html
*/

/*Question 10
Both procedures write to the same DBMS_OUTPUT buffer; the only behavioral difference is that PUT_LINE adds a newline terminator, while PUT does not.
Source: https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_OUTPUT.html
*/

-- Question 11
BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || ' &sv_YOURNAME');
END;
/

/* Q11 - It gave me a GUI which said Enter value for sv_YOURNAME: and I entered my name
new:BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || ' Katie');
END;
My name is  Katie
*/

-- Question 12
SET VERIFY ON;

--Question 13
BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || ' &sv_YOURNAME');
END;
/
/* Q13 - It looks like it just printed the same thing but took out some stuff 
PL/SQL procedure successfully completed.

My name is  Katie
*/

-- Question 14
SET VERIFY OFF;

-- Question 15
BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || ' &sv_YOURNAME');
END;
/

/* Q15
PL/SQL procedure successfully completed.

My name is  KAtie


PL/SQL procedure successfully completed.
*/

/* Question 16
The VERIFY attribute in Oracle SQLPlus controls whether the system displays both the original line of code containing a substitution variable and the line after the variable has been replaced with a user-supplied value. By default, VERIFY is set to ON, which means SQLPlus will echo “old” and “new” lines whenever a substitution occurs. Setting VERIFY OFF suppresses this echo, so only the final output appears.
*/

--Question 17 
BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YOURNAME');
END;
/

/* Q17 I was prompted once I think but it ran twice saying it was successful my name second time noting
PL/SQL procedure successfully completed.

My name is Katie


PL/SQL procedure successfully completed.

*/

--Question 18 
BEGIN 
    DBMS_OUTPUT.PUT_LINE('Today is' || ' &sv_day');
    DBMS_OUTPUT.PUT_LINE('Tomorrow is ' || ' &sv_day');
END;
Instructor
| 09/28 at 6:26 pm
Grading comment:
Can you use the same variable name twice within the same unnamed block? What
occurs if you attempt to do so?


/*Q18 Results 

Today is 1
Tomorrow is  2


PL/SQL procedure successfully completed.

*/

-- Question 19 
BEGIN 
    DBMS_OUTPUT.PUT_LINE('Today is' || ' &&sv_day');
    DBMS_OUTPUT.PUT_LINE('Tomorrow is ' || ' &sv_day');
END;

/* Q19 
Substitution cancelled
Today is 1
Tomorrow is  1

PL/SQL procedure successfully completed.
*/

/* Question 20 
I did not get prompted to write the variables the second time 
Today is 1
Tomorrow is  1


PL/SQL procedure successfully completed.
*/

-- Question 21
DECLARE
    V_DAY VARCHAR2(10) := '&sv_day1';
BEGIN 
    DBMS_OUTPUT. PUT_LINE('Today is ' || V_DAY);
END;

/* Q22 Results
PL/SQL procedure successfully completed.

Today is 2

PL/SQL procedure successfully completed.
*/

-- Question 22

DECLARE
  v_day VARCHAR2(10);
BEGIN
  v_day := TO_CHAR(SYSDATE, 'Day');

  DBMS_OUTPUT.PUT_LINE('Today is ' || v_day);
  DBMS_OUTPUT.PUT_LINE('Tomorrow is ' || TO_CHAR(SYSDATE+1, 'Day'));
END;

/* Q22 Results 
Substitution cancelled
Today is Tuesday  
Tomorrow is Wednesday

PL/SQL procedure successfully completed.
*/

-- Question 23
SELECT EmployeeID
FROM Employee
WHERE EmployeeID = '100001';

/* Q23 Results - Just One row
EMPLOYEEID
----------
100001
*/

-- Question 24

DECLARE
  v_employeeid  employee.employeeid%TYPE;
  v_lastname    employee.lastname%TYPE;
  v_firstname   employee.firstname%TYPE;
BEGIN
  SELECT employeeid, lastname, firstname
  INTO   v_employeeid, v_lastname, v_firstname
  FROM   employee
  WHERE  employeeid = '100001';

  DBMS_OUTPUT.PUT_LINE('Employee ID    LASTNAME    FIRSTNAME');
  DBMS_OUTPUT.PUT_LINE('====================================');

  DBMS_OUTPUT.PUT(v_employeeid);
  DBMS_OUTPUT.PUT('    ');
  DBMS_OUTPUT.PUT(v_lastname);
  DBMS_OUTPUT.PUT('    ');
  DBMS_OUTPUT.PUT_LINE(v_firstname);
END;

/* Q24 Results 
Employee ID    LASTNAME    FIRSTNAME
====================================
100001    Manaugh    Jim
*/

-- Question 25
SELECT EmployeeID
FROM Employee;

/* Q25 - 40 rows 

EMPLOYEEID
----------
100001
100101
100103
100104
100106
100112
100120
100125
100127
100200
100204
100206
100209
100220
100330
100365
100399
100475
100488
100550
100559
100600
100650
100700
100880
100892
100944
100967
100989
101007
101030
101045
101066
101088
101089
101097
101115
101135
101154
101166
*/

-- Question 26 
DECLARE
  v_employeeid  employee.employeeid%TYPE;
  v_lastname    employee.lastname%TYPE;
  v_firstname   employee.firstname%TYPE;
BEGIN
  SELECT employeeid, lastname, firstname
  INTO   v_employeeid, v_lastname, v_firstname
  FROM   employee; 

  DBMS_OUTPUT.PUT_LINE('Employee ID    LASTNAME    FIRSTNAME');
  DBMS_OUTPUT.PUT_LINE('=====================================');
  DBMS_OUTPUT.PUT(v_employeeid);
  DBMS_OUTPUT.PUT('    ');
  DBMS_OUTPUT.PUT(v_lastname);
  DBMS_OUTPUT.PUT('    ');
  DBMS_OUTPUT.PUT_LINE(v_firstname);
END;

/* Q26 results 
DECLARE
*
ERROR at line 1:
ORA-01422: exact fetch returns more than requested number of rows
ORA-06512: at line 6

https://docs.oracle.com/error-help/db/ora-01422/


More Details :
https://docs.oracle.com/error-help/db/ora-01422/
https://docs.oracle.com/error-help/db/ora-06512/
*/

/* Q27
In Q25 it is (one per employee), for Q26 PL/SQL block tries to put those columns into three scalar variables
*/
Instructor
| 09/28 at 6:27 pm
Grading comment:
We are trying to assign 40 values to a scalar variable that can only hold one at a time. 
This will always result in an error.


/*28
A scalar variable in PL/SQL can hold only one value at a time. If you need to handle multiple rows or values, you must use a different structure but any single scalar still stores just one value.
*/

-- Question 29 
DECLARE
  v_employee employee%ROWTYPE;
BEGIN
  SELECT * INTO v_employee FROM employee WHERE employeeid = '100001';
  DBMS_OUTPUT.PUT_LINE('Employee ID   LASTNAME   FIRSTNAME');
  DBMS_OUTPUT.PUT_LINE('===================================');
  DBMS_OUTPUT.PUT_LINE(v_employee.employeeid || '   ' || v_employee.lastname   || '   ' || v_employee.firstname);
END;

Instructor
| 09/28 at 6:27 pm
Grading comment:
What is the output (e.g., what is printed to the screen)?
Were you prompted to provide a value for the variable sv_day when the second
DBMS_OUTPUT was executed? What is different that caused this?

/* Q29 Results
Employee ID   LASTNAME   FIRSTNAME
===================================
100001   Manaugh   Jim
*/

--Question 30 
DECLARE
  v_area_code VARCHAR2(3);
BEGIN
  NULL;
END;
/* Question 30 Results

*/
--Question 31 

DECLARE
  v_max_count NUMBER;
BEGIN
  SELECT MAX(cnt)
  INTO v_max_count
  FROM (
    SELECT SUBSTR(phone,1,3) AS area_code,
           COUNT(*) AS cnt
    FROM customer
    GROUP BY SUBSTR(phone,1,3)
  );

  DBMS_OUTPUT.PUT_LINE('Largest number of customers in one area code: ' || v_max_count);
END;
/* Question 31a Results 
Largest number of customers in one area code: 8
*/

--Question 31b
DECLARE
  v_area_code VARCHAR2(3);
  v_max_count NUMBER;
BEGIN
  SELECT area_code, cnt
  INTO v_area_code, v_max_count
  FROM (
    SELECT SUBSTR(phone,1,3) AS area_code,
           COUNT(*) AS cnt
    FROM customer
    GROUP BY SUBSTR(phone,1,3)
    ORDER BY cnt DESC
  )
  WHERE ROWNUM = 1;

  DBMS_OUTPUT.PUT_LINE('Area code with most customers: ' || v_area_code);
  DBMS_OUTPUT.PUT_LINE('Number of customers: ' || v_max_count);
END;
/* Question 31b Results
Area code with most customers: 307
Number of customers: 8
*/